	/**
		----------- Definição dos conceitos base do problema -----------
	*/
	abstract sig Vehicle {
		 engine: one Engine_Status,
		 inserted_key : one Inserted_Key
	}	
	
	/** Definição dos tipos de veículo*/
	sig USA,EU,CAN extends Vehicle{}

	/** Definição dos butões */
	abstract sig Button {}
	var sig On in Button {}
	
	/** Definição do estado do motor -> ON ou OFF */
	sig Engine_Status extends Button {}

	/** Definição do estado da inserção da chave -> ON-inserida ou OFF */	
	sig  Inserted_Key extends Button {}

	/** Predicado para inserir a chave*/
	
	fact belongs {
		/* 
		Todos os veículos tem botões 
		*/
		always (all v:Vehicle| always one v.inserted_key)
		always (all v:Vehicle| always one v.engine)
		/*
		Os botões e sensores apenas pertencem a um veículo 
		*/
		always (all v1,v2 : Vehicle | v1.inserted_key = v2.inserted_key implies v1=v2)
		always (all v1,v2:Vehicle | v1.engine=v2.engine implies v1=v2)
	}
	pred insert_key [v:Vehicle]{
		
		no v.inserted_key:>On
		 
		v.inserted_key:>On' = v.inserted_key:>On + v.inserted_key
	}

	pred remove_key [v:Vehicle]{
		v.inserted_key:>On' = v.inserted_key:>On - v.inserted_key
		
	}
	 
	pred skip[]{
	On'=On
	Button'=Button
	}
	pred init{

	all e:Engine_Status| e not in On
	all k:Inserted_Key | k not in On
	
	}

	fact event {
		init and
		always (some v:Vehicle| insert_key[v] )
	}
 	run{} for 4 but exactly 2 USA
